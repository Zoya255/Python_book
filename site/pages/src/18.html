<h1>18. Особенности ООП</h1>

<p>Любой толковый IT-специалист, если разбудить его в 2 ночи и спросить про ООП, сразу же выпалит вам три слова - "наследование", "полиморфизм" и "инкапсуляция", а затем вновь завалится спать. В этой главе, мы разберёмся, что это значит и почему эти термины настолько важны.</p>

<h2>ООП на "машинках"</h2>

<p>Классический вариант объяснения особенностей объектно-ориентированного программирования - через аналогию с автомобилями.</p>

<p>Скажем, у нас есть некая машина. Если рассмотреть её как объект, то в ней можно выделить некоторые свойства и методы.</p>

<p>К свойствам любого автомобиля отнесём:</p>

<ul>
    <li>марку и название машины</li>
    <li>государственный номер</li>
    <li>количество топлива в баке</li>
    <li>расход топлива</li>
    <li>количество пройденных километров пути</li>
    <li>объём багажника</li>
    <li>количество посадочных мест</li>
    <li>и т.д. и т.п.</li>
</ul>

<p>Эти и многие другие свойства встречаются у всех автомобилей, однако отличаются их значениями. При этом, есть те значения, что являются уникальными для всех ( например, государственный номер ), а есть и те, что схожи для каких-то видов ( например, любой автобус явно имеет больше посадочных мест, чем легковые автомобили ).</p>

<p>Говоря более техническим языком, каждый объект "автомобиль" имеет свой уникальный внутренний набор данных, а так же может принадлежать к какому-то подклассу ( например, "легковой автомобиль", "грузовик" или "троллейбус" ).</p>

<p>И конечно же, у каждого автомобиля есть свои методы:</p>

<ul>
    <li>ехать</li>
    <li>поворачивать</li>
    <li>ускоряться</li>
    <li>тормозить</li>
    <li>поднимать кузов</li>
    <li>работать краном</li>
</ul>

<p>А вот тут важный момент. Первыми четырьмя методами обладает любая исправная машина. Разница в их выполнении ( скажем, максимальная скорость ) будет уже зависеть от каких-либо внутренних параметров и свойств ( скажем, от мощности мотора ). Однако базово, все они будут выполнены одинаково.</p>

<p>При этом, спецтехника может обладать другими уникальными методами, которых может и не быть у остальных видов автомобилей.</p>

<h2>Обобщённо про ООП</h2>

<p>Объектно-ориентированное программирование строится на основе классов и объектов.</p>

<p>У каждого класса ( а значит и у создаваемых на его основе объектов ) есть свои методы и параметры ( проще говоря, свойства ).</p>

<p>Один класс может содержать неограниченное количество методов и параметров.</p>

<p>Одни классы могут создаваться на основе других.</p>

<p>Объекты, созданные на основе одного и того же класса, могут быть разными, если будут содержать разные параметры. Однако при этом, методы будут всегда одинаковые.</p>

<h2>Наследование</h2>

<p>Продолжим аналогию с машинами. Как эффективнее описать всё их многообразие? На деле можно придумать много способов, однако один из самых простых и популярных - использование наследования.</p>

<blockquote>
    <p>Наследование - это принцип ООП, который позволяет создать множество классов на базе другого. Полученный при этом класс будет иметь все методы и свойства базового.</p>
</blockquote>

<blockquote>
    <p>Примечание: поскольку данный принцип берёт своё начало из биологии, то наследуемый класс принято называть также "родительским" или "материнским" ( parent class ), а образуемый класс - "дочерним" или "детским" ( child class ). Вот такие "дочки-матери".</p>
</blockquote>

<p>Как это работает в коде? Для наглядности, предположим, есть класс А, который обладает методом а:</p>

<pre><code class="lang-python">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span>:</span>
        <span class="hljs-keyword">pass</span>
</code></pre>

<p>На его основе, мы можем создать два класса - B и C, каждому из которых также зададим свой метод.</p>

<pre><code class="lang-python">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-title">A</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span></span>:
        pass

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-title">A</span>)</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span></span>:
        pass
</code></pre>

<p>В сухом остатке получается следующее. Каждый из классов имеет собственный метод, но в добавок, классы B и C наследуют метод родительского класса и могут его использовать как свои собственные:</p>

<pre><code class="lang-python">
# Собственные методы
<span class="hljs-selector-tag">A</span><span class="hljs-selector-class">.a</span>
<span class="hljs-selector-tag">B</span><span class="hljs-selector-class">.b</span>
<span class="hljs-selector-tag">C</span><span class="hljs-selector-class">.c</span>

# Унаследованные методы
<span class="hljs-selector-tag">B</span><span class="hljs-selector-class">.a</span>
<span class="hljs-selector-tag">C</span><span class="hljs-selector-class">.a</span>
</code></pre>
