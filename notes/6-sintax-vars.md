# Синтаксис простых переменных


Итак, база освоена, можно переходить к чему-то более интересному. А именно - к синтаксису простых переменных. Сначала определение.

> Синтаксис — система правил написания отдельных блоков и их связей между собой.

Проще говоря, это правила того, как нужно писать код. В Python синтаксис очень простой, но всё и в нём есть определённые правила:

- каждый новый оператор ( т.е. действие ) начинается с новой строки
- между операторами может быть один или несколько вертикальных отступов ( т.е. пустых строк )
- блоки кода отделяются друг от друга через табуляцию либо через 4 пробела
- табуляцию и пробелы смешивать нельзя

Это общие правила, которые распространяются на всё. Есть множество и других правил, но они уже более конкретные.


## Переменные

Программирование — это, прежде всего, изменение данных. А они в свою очередь хранятся в переменных. Это ключевые единицы любой программы.

> Переменная — это именованная единица, в которой содержатся какие-либо данные.

Это проще всего понять через аналогию. Представим, что коробка — это переменная, а её содержимое — это данные. В эту коробку мы можем что-то положить или что-то оттуда взять. Переменная — это и есть эта коробка. Только изменяется по имени.

Итак, к коду:

```python
int = 0
```

Это простейший пример переменной. Слово `int` - это название переменной, знак `=` - означает присваивание ( всегда левого к правому ), а цифра `0` - это значение переменной.

Ещё несколько примеров по тому же принципу:

```python
digit = 1
pin = 1234
places = 100
big = 1234567890
```


## Простые типы переменных

> Простой тип переменной — тип переменной, всегда хранящий только одно значение.

Все рассмотренные ранее переменные, относятся к одному из простых типов — целочисленному. Но конечно, это не единственный тип, их гораздо больше. Выделяют следующие простые типы переменных:


### 1. Числовые

Числовые переменные, по определению, хранят собственно числа. Python запросто может оперировать настолько большими числами, сколько доступно памяти, т.е. нет деления типов переменных по размеру числа. Однако есть разделение на виды самих чисел. Они бывают следующие:

#### 1. Целые / целочисленные
   
Т.е. положительные или отрицательные числа по порядку: `...-3, -2, -1, 0, 1, 2, 3...`. Могут быть сколь угодно большими или малыми.

Такой тип обозначается как `int`. 

Примеры:

```python
digit = 1
sum = 1000
temp = -43
```

#### 2. С плавающей запятой / вещественные числа / дробные

Это все не целые числа. Отличаются наличием точки ( а следовательно — наличием целой и дробных частей ). Такой тип имеет три важных отличительных способности от целых чисел:

- ограниченность размера — вещественные числа не могут быть сколь угодно большими ( примерный диапазон значений — от 1.8e+308 до 2.2e-308 )
- ограниченность точности — из-за особенности хранения вещественных чисел, они не хранятся целиком, а "округляются" в определённых пределах, что конечно сопровождается потерями ( именно они называются числами с плавающей запятой )
- поддержка степеней — т.е. можно хранить числа вида `2e10`, `1.3e+20` или `2.78e-1`

Такой тип обозначается как `float`

Примеры:

```python
pi = 3.14
price = 449.99
population = 8e9
```

#### 3. Комплексные / реальные

Самый необычный тип чисел, который редко используется, однако существует. Основная особенность — наличие действительных и мнимых частей. Такие числа обозначаются как `3 + 7j`, где 3 - действительная, а 7j - мнимая части. 

Такой тип обозначается как `complex`

Примеры:

```python
z = 3 + 7j
float_complex = 1.2 + 10.5j
minus_complex = -2 + -2.5j
```


### 2. Строковые

Тут всё просто, такой тип переменных хранит строку произвольной длины, будь это символ, слово, или целый текст. Для Python без разницы — будет ли это хэш, текст, число, код или что-то ещё — это всё строка. Главное — "обёрнутость" в кавычки и экранирование "опасных" символов. Но ключевая особенность этого типа — способы его создания, что будет расписано в следующих главах.

Такой тип обозначается как `string` и не имеет подразделения.

Примеры:

```python
hash = "7ihg89wqp8yghwty4t8p9g8ibqup98gbF8903P8IG8Ffe3jceP9rtg78ufr3"
char = "a"
text = "Lorem ipsum dolor sit amet, consectetur adipisicing elit."
json = "{ 'orderID': 12345 }"
num  = "12345"
```


### 3. Логические

Тип, который отвечает на вопрос - "Быть или не быть?", т.е. хранит значение "да" и "нет". Он всегда принимает лишь два значения - `True` ( правда ) и `False` ( ложь ).

Такой тип обозначается как `bool`.

```python
is_apple_red = True
evil_is_good = False
boolean = True
```


## Преобразование типов

В Python достаточно много разнообразных типов, но как он понимает, где какой? И как этим можно управлять? Начнём разбор по порядку.

### 1. Динамическая типизация

Ещё в первой главе говорилось о том, что Python - это динамически типизованный язык, т.е. он сам понимает, где какой тип на ходу, при создании переменной. Это работает примерно так:

- если объект обёрнут в кавычки — `'object'` или `"object"`, то это строка, даже если внутри кавычек числа, т.е. `'2'` - это строка
  
- если объект без кавычек, то:
	- если он состоит из цифр — то это число, например, `20` или `3.14`
	- если это зарезервированные слова `True` или `False` — то это логический тип

> Примечание: это условное объяснение, которое не включает в себе массивы, объекты, классы и прочее

### 2. Динамическая строгая типизация

И если ранее рассматривалась лишь динамическая типизация, то теперь пора узнать, что на самом деле она ещё и строгая.

> Строгая типизация означает, что тип, который был присвоен переменной при её инициализации ( создании ) будет закреплён за ней и не будет изменяться.

Такое решение необходимо для:

- уменьшения лишних вычислений ( не нужно каждый раз пересчитывать переменную )
- повышения ясности ( переменная никогда неожиданно не поменяет тип )
- преобладания явных преобразований ( у каждой смены типа есть причина )

### 3. Неявные преобразования

> Неявное преобразование типа — изменение типа переменной без явного указания на преобразования.

Рассмотрим следующий пример. Какой тип у переменных `x` и `y`?

```python
int1 = 2
int2 = 4
float = 0.5

x = int1 + float
y = int1 / int2
```

Правильный ответ: `float`, несмотря на то, что производились взаимодействия других типов. Только что произошло неявное преобразование. Иначе говоря, это изменение типа "на лету".

Например, `float` + `int` дают всегда `float`, даже если возможно преобразование в `int`.

Однако в Python таких преобразований мало, они логичны и необходимы для выполнения различных операций без потерь. Меж тем, такие странности как сложение `str` и `int` невозможны.

### 4. Явные преобразования

> Явное преобразование типа — изменение типа переменной при явном указании.

Явное преобразование производится при помощи функций. Например, превращение `float` в `int`:

```shell
>>> int(2.0)
2
```

Возможные преобразования:

#### 1. int

В тип `int` можно преобразовать `float` или `str`:

```python
to_int1 = int(2.0) # 2
to_int2 = int('2') # 2
```

#### 2. float

В тип `float` можно преобразовать `int` или `str`:

```python
to_float1 = float(2)     # 2.0
to_float2 = float('2')   # 2.0
to_float3 = float('2.0') # 2.0
```

#### 3. complex

В тип `complex` можно преобразовать `int`, `float`, `str` или их смесь:

```python
to_complex1 = complex(2)            # (2+0j)
to_complex2 = complex(2, 4)         # (2+4j)
to_complex3 = complex(2.5)          # (2.5+0j)
to_complex4 = complex(2.5, 2)       # (2.5+2j)
to_complex5 = complex('2')          # (2+0j)
to_complex6 = complex('2', '4')     # (2+4j)
to_complex7 = complex('2.5')        # (2.5+0j)
to_complex8 = complex('2.5', '3.1') # (2.5+3.1j)
```

#### 4. str

В тип str можно преобразовать любой другой тип:

```python
to_str1 = str(2)         # '2'
to_str2 = str(2.0)       # '2.0'
to_str3 = str(2+2j)      # '(2+2j)'
to_str4 = str([1, 2, 3]) # '[1, 2, 3]'
to_str5 = str(True)      # 'True'
to_str6 = str('abc')     # 'abc'
```

#### 5. bool

В тип bool можно преобразовать любой другой тип:

```python
to_bool   = bool()          # False 
to_bool1  = bool(1)         # True
to_bool2  = bool(0)         # False
to_bool3  = bool(1.0)       # True
to_bool4  = bool(0.0)       # False
to_bool5  = bool(1+1j)      # True
to_bool6  = bool(0+0j)      # False
to_bool7  = bool([1, 2, 3]) # True
to_bool8  = bool([])        # False
to_bool9  = bool(True)      # True
to_bool10 = bool(False)     # False
to_bool11 = bool('abc')     # True
to_bool12 = bool('')        # False
```
