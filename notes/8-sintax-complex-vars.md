# Синтаксис сложных переменных


Итак, с теорией массивов и не только уже всё ясно. Настало время практики.

> Примечание: Эта одна из самых загруженных и больших глав, прямое продолжение предыдущей главы.

И начнётся всё с неожиданной новости — из-за философии Python, в этом языке по умолчанию нет массивов. Вместо них используется целых четыре их разновидности — списки, словари, кортежи и множества. Каждый из них хорошо подходит под свою отдельную задачу, и пусть самые часто используемые лишь первые два — знать лучше про все.


## Синтаксис

Синтаксис всех видов массива в Python очень похож, поэтому стоит их разобрать сразу. К тому же он по сути такой же, как и в других языках.

Для создания "массива" используется одна из следующих видов записи. Они все схожи, и в основном различаются в используемых скобках, но об этом позже:

```python
# пустой массив
empty_array = []

# массив с элементами
num_array = [ 1, 2, 3, 4, 5 ]
str_array = [ "a", "b", "c" ]
array     = [ 1, "a", 2, "b", True ]

# многомерный массив
two_dim_array   = [ [ 1, 2, 3 ], [ "a", "b", "c" ], [ 1, "a", True ] ]

# многомерный массив ( развёрнутый ) 
test_array = [
	[ 
		"Что такое Python?", 
		0,
		[
			'Язык программирования',
			'Змея'
		]
	]
]
```

Обращение к элементу массива идёт по его индексу. Записывается это следующим образом:

```python
arr = [ 1, 2, 3 ]

# получение значений элементов и их вывод на экран
print( arr[0] )
print( arr[1] )
print( arr[2] )

# изменение значения элементов
arr[0] = 3
arr[1] = 2
arr[2] = 1
```

### Особые возможности
 
Помимо обычных действий, над массивами можно также производить следующие действия:

```python
# Сложение массивов
arr1 = [ 1, 2 ]
arr2 = [ 3, 4 ]

arr = arr1 + arr2  # [ 1, 2, 3, 4 ]

# Умножение массива на число
arr = arr * 2  # [ 1, 2, 3, 4, 1, 2, 3, 4 ]
```

Конечно, это ещё не все особенности, просто некоторые из них будут разобраны позже, в последующих главах.


## 1. Списки

Это наиболее "классический" вариант массива, как и в концепции, так и синтаксисе. Может принимать любые типы данных.

> Список — упорядоченная изменяемая последовательность объектов. 

Тип переменной - `list`.

### Синтаксис:

```python
# Создание списка
numbers_list  = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]

# Получение значения
num1 = numbers_list[ 0 ]   # 1
num2 = numbers_list[ 1 ]   # 2
num3 = numbers_list[ 8 ]   # 9
num4 = numbers_list[ -1 ]  # 0

# Изменение значения
numbers_list[ 0 ] = num2  # 1 => 2 
numbers_list[ 1 ] = num1  # 2 => 1
numbers_list[ 3 ] = 40    # 4 => 40
```

### Преобразования

Кстати, как и с более простыми переменными, в список можно преобразовать и другие типы, такие как строка или другие типы массивов:

```shell
>>> list( "array" )
[ 'a', 'r', 'r', 'a', 'y' ]

>>> list( ( 1, 2, 3 ) )
[ 1, 2, 3 ]

>>> list( { "a": "b" } )
[ 'a' ]

>>> list( { 1, 2, 3 } )
[ 1, 2, 3 ]
```

> Примечание: При преобразовании словаря ( что это — смотри ниже ) в список ( как и при многих других операциях со словарями, используются только ключи, а не их значения )


## 2. Словари

Данная реализация словаря также не сильно отличается от его алгоритмического собрата. В целом, это реализовано, как и обычный список, однако элементы не пронумерованы, а названы. Это позволяет создавать более понятные структуры данных. В целом, это сильно похоже на JSON.

> Словарь — упорядоченная изменяемая последовательность именованных элементов.

Тип переменной - `dict`.

### Синтаксис:

```python
# Создание словаря
conf_dict = { "color": "white", "font": "Consolas", "size": "12px" }

# Получение значений
conf1 = conf_dict[ "color" ]  # 'white'
conf2 = conf_dict[ "font" ]   # 'Consolas'
conf3 = conf_dict[ "size" ]   # '12px'

# Изменение значений
conf_dict[ "color" ] = "black"
conf_dict[ "font" ]  = "Arial"
conf_dict[ "size" ]  = "16px"
```

### Преобразования

Словари также можно получить и из других типов, но из-за его структуры это сделать сложнее. Нужно соблюсти главное условие — преобразуемый объект должен сам быть каким-либо типом массива, а каждый элемент должен содержать ещё два ( они как раз и станут ключом и значением соответственно ).

Это выглядит примерно так:

```shell
>>> dict( [ [ 1, 2 ], [ "a", "b" ], [ "b", True ] ] )
{1: 2, 'a': 'b', 'b': True}

>>> dict( ( ( "id", 3 ), ( "name", "sergo" ) ) )
{'id': 3, 'name': 'sergo'}

>>> dict( { ( 1, 2 ), ( 3, 4 ), ( 5, 6 ) } )
{1: 2, 3: 4, 5: 6}
```


## 3. Кортежи

Проще говоря, это неизменяемый список. Это набор-константа, который нельзя изменить, лишь создать или получить значение. А в остальном — это обычный список, со всеми особенностями.

> Кортеж — это упорядоченная постоянная ( неизменяемая ) последовательность элементов.

Тип переменной - `tuple`.

### Синтаксис

```python
# Создание кортежа
row_tuple = ( 1, "Sergo", "sergo@example.com", "password" )

# Получение значений
row1 = row_tuple[ 0 ]  # 1
row2 = row_tuple[ 1 ]  # 'Sergo'
row3 = row_tuple[ 2 ]  # sergo@example.com
row4 = row_tuple[ 3 ]  # password
```

### Постоянность кортежа

Сама суть кортежа - в его неизменяемости. Так что при попытке его изменить, Python выдаст исключение ( т.е. ошибку, а что это и зачем, будет разобрано потом ):

```shell
>>> row_tuple = ( 1, 2, 3 )

>>> row_tuple[0] = 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

Вольный перевод этого исключения гласит:

> Ошибка типа: объект типа "кортеж" не может быть изменён

Поэтому сам кортеж изменить нельзя. Можно лишь пересоздать.

Также из кортежа нельзя убирать / добавлять элементы напрямую. Банально нет таких методов. Однако есть одна хитрость, которая позволит добавить элементы в кортеж. Это сложить основной кортеж с кортежем тех элементов, что требуется добавить:

```shell
>>> main_tuple = ( 1, 2, 3, 4, 5, 6 )
>>> add_tuple  = ( 7, 8, 9 )

>>> main_tuple = main_tuple + add_tuple

>>> main_tuple
(1, 2, 3, 4, 5, 6, 7, 8, 9)
```


### Преобразования:

Из-за схожести с обычным списком, в кортеж можно преобразовать то же, что и в список — строки и другие типы массивов:

```shell
>>> tuple( "just str" )
('j', 'u', 's', 't', ' ', 's', 't', 'r')

>>> tuple( [ "x", "y", "z" ] )
('x', 'y', 'z')

>>> tuple( { "red": 255, "green": 255, "blue": 255 } )
('red', 'green', 'blue')

>>> tuple( { "alfa", "beta", "gamma" } )
('alfa', 'beta', 'gamma')
```


## 4. Множества

Этот тип массива тесно пересекается с математикой. Там множеством считается просто набор каких-либо элементов, обычно чисел. Реализация в Python та же самая.

Однако у множества есть одна ключевая особенность — элементы в нём не могут повторяться. Таким образом, множества гарантируют лишь сохранность элементов, находящихся в них, но никак не порядок и очерёдность. Может случиться даже так, что порядок элементов будет перемешан.

Ещё одна особенность множества — это полное отсутствие индексации. Проще говоря, нельзя обратится к конкретному элементу множества. Они все составляют единое целое. Из-за этого вытекает невозможность как получения, так и изменения данных в нём.

> Множество — это неупорядоченный неизменяемый набор уникальных элементов.

Тип переменной - `set`.

### Синтаксис

```python
# Создание множества
math_set = { 1, 2, 3, 4, 5 }
```

> Примечание: нельзя создать пустое множество с помощью записи а-ля `set = {}`, т.к. получившийся объект будет словарём.

> Предупреждение: работа с множествами не идёт напрямую, а лишь обобщённо, через методы. Подробнее об этом смотри в главе 10.

### Преобразование:

В множество легко и просто можно преобразовать как строку, так и другие типы массивов, при этом повторяющиеся элементы будут удалены:

```shell
>>> set( "very very long string of type str" )
{'l', 'i', ' ', 'y', 's', 'e', 'o', 'n', 'g', 'p', 'f', 'r', 't', 'v'}

>>> set( [ "a", "b", "a", "b", "c" ] )
{'a', 'c', 'b'}

>>> set( ( 1, 2, 3, 4, 5, 6, 7 ) )
{1, 2, 3, 4, 5, 6, 7}

>>> set( { "a": "b", "b": "c", "c": "d" } )
{'a', 'c', 'b'}
```
