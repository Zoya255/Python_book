# Классы и методы


Теперь, когда вы изучили то, как организованы и работают функции, можно переходить к чуть более сложным, но важным и интересным вещам - таким как собственно ООП.


## Что такое ООП?

> Объектно-ориентированное программирование ( ООП ) - это подход к программированию на основе объектов.

ООП позволяет строить программу напрямую из обрабатываемых ей объектов, а не думать об их составляющих. Это значительно ускоряет и облегчает процесс написания кода.

Например, если вы создаёте игру, то ООП позволит создать такие объекты как "машина", "игрок" и "оружие игрока", а затем просто управлять этим объектами, вместо того, чтобы каждый раз думать о глубинных составляющих частях игры.

Такой код выглядел бы примерно так:

```text
игрок.пройти_вперёд()
игрок.взять_оружие('АК-47')
игрок.пройти_вперёд()
игрок.сесть_в_машину('Танк')
```

И в самом деле, ООП состоит из объектов. Объектом будем считать игрока ( объект "игрок" ). А всё, что идёт после объекта - это уже действия, доступные игроку ( функции объекта, например, "пройти_вперёд()" ).

В реальном программировании, такие объекты называются классами, а функции объекта - методами.


## Что такое класс?

> Класс - это именованный проект объекта.

Тут важно сразу пояснить, что класс - это не объект. Это разные понятия. Проще говоря, класс - это чертёж дома, а объект - это дом, построенный по чертежу. При этом, дома могут немного разниться между собой, имея при этом абсолютно одинаковый каркас, ибо они сделаны по одному и тому же чертежу.

В программировании это работает точно также. На основе одного и того же класса можно создать множество объектов, они будут иметь одинаковые методы, но при этом разные названия и возможно данные.


## Что такое метод?

> Метод - это функция отдельно взятого класса.

Проще, говоря, методы - это действия, производимые какими-либо объектами. Например, у объекта "человек" могут быть такие методы как "ходить", "говорить", "сидеть", "бегать", "прыгать" и т.д. Фактически, можно даже сказать, что классы ( и соответственно получаемые из них объекты ) нужны для группировки методов ( функций ). По этой же причине, классы иногда называют функциями второго порядка ( или нечто подобное ).


## Объекты, классы и методы в Python 3

Теперь, разберёмся с тем, как же это пишется в коде. Для начала синтаксис:

```python
class ClassName:
	def method_name(self, param):
		return param
```

Здесь:

- `class` - ключевое слово, объявление нового класса
- `class_name` - это собственно название класса

> Примечание: в Python 3 названия классов принято писать в CamelCase, а названия методов - в snake_case.

Технически, получился класс, с единственным методом, который просто возвращает переданное ему значение.

Метод пишется точно также, как и функция, но принадлежит классу ( имеет дополнительный отступ ) и включает в себя специальный параметр `self`.

Параметр `self` - это специальный параметр функции, который предназначен для "внутренних" обращений к методам и данным класса и при этом не виден "снаружи".

Разберём на примере:

```python
class TestData:
	def __init__(self, data):
		self.data = data
	
	def get(self):
		return self.data
```

Этот класс решает лишь одну прикладную задачу - хранение данных. При инициализации он становится объектом, получает некое значение, хранит его "внутри" себя ( в параметре `self` ) и может вернуть при помощи метода `get()`.

Вот как это будет работать:

```python
# Инициализация объекта
some_data = TestData(5)

# Какие-то ещё действия
print( 'Something...' )

# Вывод данных из объекта
print( some_data.get() )
```

Тут рассмотрено три действия:

- Прежде всего, это инициализация. Упрощённо, это превращение класса в объект с задаванием ему имени и параметров. В данном случае класс `TestData` стал объектом `some_data` и получил значение `5`. Уже внутри это значение перешло во внутренний параметр `self.data`.
- Далее могут происходить какие-либо иные действия программы, это не важно, ибо объект будет "жить" всё это время и ждать, пока он пригодится.
- Затем объект снова может использоваться. В примере вызывается его единственный метод `get()`, возвращающий ранее полученное значение.

Технически, если предположить, что это не конец программы и дальше этот объект больше не будет использоваться, то тогда его нужно уничтожить, дабы не тратить память в пустую. В крупных программах для этого даже применяются такие механизмы, как "сборщики мусора", которые автоматически уничтожают все более не нужные объекты в целях экономии памяти. 

> Теоретически, к вышеприведённому примеру класса можно даже добавить метод `set()` для установки нового значения и использования получившегося объекта как переменной. Что в целом не рекомендуется в связи с большими затратами памяти ( в сравнении с обычными переменными ). Однако, это может иметь смысл для создания и хранения собственных типов данных.


## Немного о декораторах

А теперь создадим класс, который будет включать в себя методы для простых математических расчётов:

```python
class EasyMath:
	@staticmethod
	def plus( int1, int2 ):
		return int1 + int2
	
	@staticmethod
	def minus( int1, int2 ):
		return int1 - int2
		
	@staticmethod
	def multiply( int1, int2 ):
		return int1 * int2
		
	@staticmethod
	def divide( int1, int2 ):
		return int1 / int2
```

Довольно просто, однако у вас должны возникнуть два вопроса:

- Что такое `@staticmethod`?
- Куда делся параметр `self`?

Всё просто: данный класс - это пример обычного группирования функций. Методы в нём статичные, живущие "сами по себе", словно и не принадлежат классу. И поэтому в статичных методах специальный ( и необходимый для всех остальных методов ) параметр `self` не используется.

Однако метод не может объявить свою "независимость" и статичность сам по себе. Это за него делает специальный декоратор `@staticmethod`.

> Декоратор - это обёрточная функция, которая изменяет поведение идущей за ней функции.

Проще говоря декоратор `@staticmethod` объявляет: "Следующая прямо за мной функция статична!"
